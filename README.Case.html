<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Case</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the case expressions can be used with anonymous</a>
<a id="178" class="Comment">-- pattern-matching lambda abstractions</a>
<a id="218" class="Comment">------------------------------------------------------------------------</a>

<a id="292" class="Symbol">{-#</a> <a id="296" class="Keyword">OPTIONS</a> <a id="304" class="Pragma">--cubical-compatible</a> <a id="325" class="Pragma">--safe</a> <a id="332" class="Symbol">#-}</a>

<a id="337" class="Keyword">module</a> <a id="344" href="README.Case.html" class="Module">README.Case</a> <a id="356" class="Keyword">where</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="386" class="Keyword">hiding</a> <a id="393" class="Symbol">(</a><a id="394" href="Data.Fin.Base.html#6461" class="Function">pred</a><a id="398" class="Symbol">)</a>
<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="423" class="Keyword">hiding</a> <a id="430" class="Symbol">(</a><a id="431" href="Data.Maybe.Base.html#1935" class="Function">from-just</a><a id="440" class="Symbol">)</a>
<a id="442" class="Keyword">open</a> <a id="447" class="Keyword">import</a> <a id="454" href="Data.Nat.html" class="Module">Data.Nat</a>   <a id="465" class="Keyword">hiding</a> <a id="472" class="Symbol">(</a><a id="473" href="Data.Nat.Base.html#4279" class="Function">pred</a><a id="477" class="Symbol">)</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="Function.Base.html" class="Module">Function.Base</a> <a id="505" class="Keyword">using</a> <a id="511" class="Symbol">(</a><a id="512" href="Function.Base.html#4033" class="Function Operator">case_of_</a><a id="520" class="Symbol">;</a> <a id="522" href="Function.Base.html#2951" class="Function Operator">case_return_of_</a><a id="537" class="Symbol">)</a>
<a id="539" class="Keyword">open</a> <a id="544" class="Keyword">import</a> <a id="551" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>

<a id="569" class="Comment">------------------------------------------------------------------------</a>
<a id="642" class="Comment">-- Different types of pattern-matching lambdas</a>

<a id="690" class="Comment">-- absurd pattern</a>

<a id="empty"></a><a id="709" href="README.Case.html#709" class="Function">empty</a> <a id="715" class="Symbol">:</a> <a id="717" class="Symbol">∀</a> <a id="719" class="Symbol">{</a><a id="720" href="README.Case.html#720" class="Bound">a</a><a id="721" class="Symbol">}</a> <a id="723" class="Symbol">{</a><a id="724" href="README.Case.html#724" class="Bound">A</a> <a id="726" class="Symbol">:</a> <a id="728" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="732" href="README.Case.html#720" class="Bound">a</a><a id="733" class="Symbol">}</a> <a id="735" class="Symbol">→</a> <a id="737" href="Data.Fin.Base.html#1154" class="Datatype">Fin</a> <a id="741" class="Number">0</a> <a id="743" class="Symbol">→</a> <a id="745" href="README.Case.html#724" class="Bound">A</a>
<a id="747" href="README.Case.html#709" class="Function">empty</a> <a id="753" href="README.Case.html#753" class="Bound">i</a> <a id="755" class="Symbol">=</a> <a id="757" href="Function.Base.html#4033" class="Function Operator">case</a> <a id="762" href="README.Case.html#753" class="Bound">i</a> <a id="764" href="Function.Base.html#4033" class="Function Operator">of</a> <a id="767" class="Symbol">λ</a> <a id="769" class="Symbol">()</a>

<a id="773" class="Comment">-- {}-delimited and ;-separated list of clauses</a>
<a id="821" class="Comment">-- Note that they do not need to be on different lines</a>

<a id="pred"></a><a id="877" href="README.Case.html#877" class="Function">pred</a> <a id="882" class="Symbol">:</a> <a id="884" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="886" class="Symbol">→</a> <a id="888" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="890" href="README.Case.html#877" class="Function">pred</a> <a id="895" href="README.Case.html#895" class="Bound">n</a> <a id="897" class="Symbol">=</a> <a id="899" href="Function.Base.html#4033" class="Function Operator">case</a> <a id="904" href="README.Case.html#895" class="Bound">n</a> <a id="906" href="Function.Base.html#4033" class="Function Operator">of</a> <a id="909" class="Symbol">λ</a>
  <a id="913" class="Symbol">{</a> <a id="915" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="923" class="Symbol">→</a> <a id="925" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="932" class="Symbol">;</a> <a id="934" class="Symbol">(</a><a id="935" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="939" href="README.Case.html#939" class="Bound">n</a><a id="940" class="Symbol">)</a> <a id="942" class="Symbol">→</a> <a id="944" href="README.Case.html#939" class="Bound">n</a>
  <a id="948" class="Symbol">}</a>

<a id="951" class="Comment">-- where-introduced and indentation-identified block of list of clauses</a>

<a id="from-just"></a><a id="1024" href="README.Case.html#1024" class="Function">from-just</a> <a id="1034" class="Symbol">:</a> <a id="1036" class="Symbol">∀</a> <a id="1038" class="Symbol">{</a><a id="1039" href="README.Case.html#1039" class="Bound">a</a><a id="1040" class="Symbol">}</a> <a id="1042" class="Symbol">{</a><a id="1043" href="README.Case.html#1043" class="Bound">A</a> <a id="1045" class="Symbol">:</a> <a id="1047" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1051" href="README.Case.html#1039" class="Bound">a</a><a id="1052" class="Symbol">}</a> <a id="1054" class="Symbol">(</a><a id="1055" href="README.Case.html#1055" class="Bound">x</a> <a id="1057" class="Symbol">:</a> <a id="1059" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1065" href="README.Case.html#1043" class="Bound">A</a><a id="1066" class="Symbol">)</a> <a id="1068" class="Symbol">→</a> <a id="1070" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1080" href="README.Case.html#1055" class="Bound">x</a>
<a id="1082" href="README.Case.html#1024" class="Function">from-just</a> <a id="1092" href="README.Case.html#1092" class="Bound">x</a> <a id="1094" class="Symbol">=</a> <a id="1096" href="Function.Base.html#2951" class="Function Operator">case</a> <a id="1101" href="README.Case.html#1092" class="Bound">x</a> <a id="1103" href="Function.Base.html#2951" class="Function Operator">return</a> <a id="1110" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1120" href="Function.Base.html#2951" class="Function Operator">of</a> <a id="1123" class="Symbol">λ</a> <a id="1125" class="Keyword">where</a>
  <a id="1133" class="Symbol">(</a><a id="1134" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="1139" href="README.Case.html#1139" class="Bound">x</a><a id="1140" class="Symbol">)</a> <a id="1142" class="Symbol">→</a> <a id="1144" href="README.Case.html#1139" class="Bound">x</a>
  <a id="1148" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>  <a id="1157" class="Symbol">→</a> <a id="1159" class="Symbol">_</a>

<a id="1162" class="Comment">------------------------------------------------------------------------</a>
<a id="1235" class="Comment">-- We can define some recursive functions with case</a>

<a id="plus"></a><a id="1288" href="README.Case.html#1288" class="Function">plus</a> <a id="1293" class="Symbol">:</a> <a id="1295" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1297" class="Symbol">→</a> <a id="1299" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1301" class="Symbol">→</a> <a id="1303" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="1305" href="README.Case.html#1288" class="Function">plus</a> <a id="1310" href="README.Case.html#1310" class="Bound">m</a> <a id="1312" href="README.Case.html#1312" class="Bound">n</a> <a id="1314" class="Symbol">=</a> <a id="1316" href="Function.Base.html#4033" class="Function Operator">case</a> <a id="1321" href="README.Case.html#1310" class="Bound">m</a> <a id="1323" href="Function.Base.html#4033" class="Function Operator">of</a> <a id="1326" class="Symbol">λ</a>
   <a id="1331" class="Symbol">{</a> <a id="1333" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1341" class="Symbol">→</a> <a id="1343" href="README.Case.html#1312" class="Bound">n</a>
   <a id="1348" class="Symbol">;</a> <a id="1350" class="Symbol">(</a><a id="1351" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1355" href="README.Case.html#1355" class="Bound">m</a><a id="1356" class="Symbol">)</a> <a id="1358" class="Symbol">→</a> <a id="1360" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1364" class="Symbol">(</a><a id="1365" href="README.Case.html#1288" class="Function">plus</a> <a id="1370" href="README.Case.html#1355" class="Bound">m</a> <a id="1372" href="README.Case.html#1312" class="Bound">n</a><a id="1373" class="Symbol">)</a>
   <a id="1378" class="Symbol">}</a>

<a id="div2"></a><a id="1381" href="README.Case.html#1381" class="Function">div2</a> <a id="1386" class="Symbol">:</a> <a id="1388" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1390" class="Symbol">→</a> <a id="1392" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="1394" href="README.Case.html#1381" class="Function">div2</a> <a id="1399" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1407" class="Symbol">=</a> <a id="1409" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
<a id="1414" href="README.Case.html#1381" class="Function">div2</a> <a id="1419" class="Symbol">(</a><a id="1420" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1424" href="README.Case.html#1424" class="Bound">m</a><a id="1425" class="Symbol">)</a> <a id="1427" class="Symbol">=</a> <a id="1429" href="Function.Base.html#4033" class="Function Operator">case</a> <a id="1434" href="README.Case.html#1424" class="Bound">m</a> <a id="1436" href="Function.Base.html#4033" class="Function Operator">of</a> <a id="1439" class="Symbol">λ</a> <a id="1441" class="Keyword">where</a>
  <a id="1449" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="1458" class="Symbol">→</a> <a id="1460" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="1467" class="Symbol">(</a><a id="1468" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1472" href="README.Case.html#1472" class="Bound">m′</a><a id="1474" class="Symbol">)</a> <a id="1476" class="Symbol">→</a> <a id="1478" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1482" class="Symbol">(</a><a id="1483" href="README.Case.html#1381" class="Function">div2</a> <a id="1488" href="README.Case.html#1472" class="Bound">m′</a><a id="1490" class="Symbol">)</a>


<a id="1494" class="Comment">-- Note that some natural uses of case are rejected by the termination</a>
<a id="1565" class="Comment">-- checker:</a>

<a id="1578" class="Comment">-- module _ {a} {A : Set a} (eq? : Decidable {A = A} _≡_) where</a>

<a id="1643" class="Comment">--  pairBy : List A → List (A ⊎ (A × A))</a>
<a id="1684" class="Comment">--  pairBy []           = []</a>
<a id="1713" class="Comment">--  pairBy (x ∷ [])     = inj₁ x ∷ []</a>
<a id="1751" class="Comment">--  pairBy (x ∷ y ∷ xs) = case eq? x y of λ where</a>
<a id="1801" class="Comment">--    (yes _) → inj₂ (x , y) ∷ pairBy xs</a>
<a id="1842" class="Comment">--    (no _)  → inj₁ x ∷ pairBy (y ∷ xs)</a>
</pre></body></html>